This one is heavy.

== To start from scratch ==

  # Clone the repo
  # Check for bootstrap vars in Makefile (VENV_DIR)
  # make bootstrap, follow instructions (e.g. source venv/bin/activate)
  # make t (should pass all tests)
  # mv README docs/from_scratch.txt
  # Check for other vars in Makefile (NONTESTS, PROJECT_NAME, etc.)
  # rm -rf .git && git init

== Workflow for frontend would go something like this: ==

1. Place Closure-namespaced JS files under `assets/js/<name>/`
  * add tests to `assets/js/all_tests.js`
  * you can then run tests individually, e.g. `/js/notepad/notepad_test.html` or all of them from `/js/all_tests.html`
  
  See http://closure-library.googlecode.com/svn/docs/index.html for API docs.

3. If you have Soy templates, do `make soy2js`.

  This will compile `templates/soy/*.soy` into `assets/js/<soy_filename>/soy.js`.
  See https://developers.google.com/closure/templates/docs/commands for template commands.

2. When you add new JS namespaces/modules/files, make sure to run `make jsdeps`

  Also, always run jsdeps _after_ soy2js.

4. `make js` will compile the whole thing into `assets/js/compiled.js`
   
  To compile with i18n support, do this first:
    * check PROJECT_NAME var in Makefile
    * `make js_extract_msg`. This will create locale/messages.xtb. Pass it on to the translation team.
    *  put translated files into locale/xx/LC_MESSAGES/messages.xtb
    * compile the whole thing with `make js LOCALE=xx`

5. For CSS, just do `make css`. 

  This will compile all `assets/css/*.gss` into `assets/css/compiled.css`.
  See http://code.google.com/p/closure-stylesheets/ for details on GSS.

== Jinja2 templates ==

In dev mode, deps.js and goog/base.js should be referenced in a layout template.
When switching to production/compiled mode, those will be removed/replaced with compiled.js.

TODO: explain 
  * how that happens
  * how to use Closure modules
  * how to switch between dev/production templates

== backend testing ==

All tests should be placed in tests/ dir. Just create a new file named xxx_test.py,
it'll be automatically found and ran when you `make t`

To run indivitual test files, do `make t MOD=xxx_test`

See tests/handlers_base_test.py for handlers/functional testing, 
tests/user_test.py for model testing.

To see tests coverage, do `make cov`. It'll display results in console and
generate HTML report: "open htmlcov/index.html".

Some resources on testing:
  * http://webtest.pythonpaste.org/en/latest/modules/webtest.html
  * https://developers.google.com/appengine/docs/python/tools/localunittesting


== make help ==

{{{
Use 'make <target>' where <target> is one of

  (t)est      to run unit testing. For a single module test use this:
              make t MOD=mod_name
  (cov)erage  to make test coverage report
  (s)erve     to start the app on development server
  (r)emote    to run Remote API shell

  bootstrap   to generate virtualenv in  (ONCE, at the very beginning) 
              and install needed packages from requirements.txt

  == i18n and Babel

  1. babel_extract                     - extracts all translactions according to babel.cfg
  2. babel_init LOCALE=<your_locale>   - inits messages.pot (ONCE per language)
  3. translate locale/<lang>/LC_MESSAGES/messages.po
  4. babel_compile                     - compiles all translations
  - iterate: 
    * repeat step 1.
    * run 'make babel_update LOCALE=<your_locale>'
    * repeat step 3 and 4

  == Closure-related stuff

  css              to compile assets/css/*.gss into assets/css/compiled.css
  jsdeps           to generate assets/js/deps.js
  (js)compile      to compile JS assets into assets/js/compiled.js
  js_extract_msg LOCALE=xx  to extract goog.getMsg() in XTB format > locale/messages.xtb
  soy2js           to compile Soy templates

  == Deployment-related stuff

  deploy      to deploy the app on production servers. You could do
              make deploy VER=myver FLAGS=-v

You can always use FLAGS='--whatever' as addition arguments to any target.
}}}
